\documentclass[10pt]{article}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
\usepackage{setspace}
\usepackage{ragged2e}
\usepackage{color}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{float}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage[font=small,labelfont=bf,labelsep=period]{caption}
\usepackage[english]{babel}
\usepackage{indentfirst}
\usepackage{array}
\usepackage{makecell}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{arydshln}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xfrac}
\usepackage{etoolbox}
\usepackage{cite}
\usepackage{url}
\usepackage{dcolumn}
\usepackage{hyperref}
\usepackage{courier}
\usepackage{url}
\usepackage{esvect}
\usepackage{commath}
\usepackage{verbatim} % for block comments
\usepackage{enumitem}
\usepackage{hyperref} % for clickable table of contents
\usepackage{braket}
\usepackage{titlesec}
\usepackage{booktabs}
\usepackage{gensymb}
\usepackage{longtable}
\usepackage{listings}
\usepackage{cancel}
\usepackage{tcolorbox}
\usepackage[mathscr]{euscript}
\lstset{
    frame=single,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

% for circled numbers
\usepackage{tikz}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}


\titleclass{\subsubsubsection}{straight}[\subsection]

% define new command for triple sub sections
\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

\newcommand{\volume}{\mathop{\ooalign{\hfil$V$\hfil\cr\kern0.08em--\hfil\cr}}\nolimits}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\begin{document}

\title{MATH 228b: HW1 ..... 2, 3, 4}
\author{April Novak}

\maketitle

\section{}

Transfinite Interpolation (TFI) is used to map from a master domain (defined in 2-D over \(0\leq\xi\leq1\) and \(0\leq\eta\leq1\)) to the physical domain by expressing the boundary of the physical domain in terms of \(\xi,\eta\) coordinates. This then constrains the master grid to lie within the physical domain boundaries. TFI does not guarantee a one-to-one mapping or orthogonality of the mesh, however, but is useful for directly controlling the grid spacing in a computationally efficient and easy manner. The mapping from the master domain to the physical domain is given by \(\textbf{X}(\xi,\eta)\):

\begin{equation}
\textbf{X}(\xi,\eta)=\left\lbrack x(\xi,\eta), y(\xi,\eta)\right\rbrack^T
\end{equation}

where \(x(\xi,\eta)\) and \(y(\xi,\eta)\) are the mappings from the individual coordinates in the master domain (\(\xi,\eta\)) to those in the physical domain (\(x,y\)). For \textit{linear} TFI, we construct 1-D, \textit{linear} interpolants in the \(x\) and \(y\) directions:

\begin{equation}
\begin{aligned}
\textbf{U}(\xi,\eta)=& (1-\xi_i)\textbf{X}(0,\eta_j)+\xi_i\textbf{X}(1,\eta_j)\\
\textbf{V}(\xi,\eta)=& (1-\eta_j)\textbf{X}(\xi_i,0)+\eta_j\textbf{X}(\xi_i,1)\\
\end{aligned}
\end{equation}

where \(\textbf{U}\) is the 1-D interpolant in the \(x\)-direction and \(\textbf{V}\) the 1-D interpolant in the \(y\)-direction. For a 2-D domain, \(x\) and \(y\) are functions of \(\xi\) and \(\eta\). The 2-D interpolant is constructed from the 1-D interpolants above by performing a Boolean sum.

\begin{equation}
\begin{aligned}
\textbf{X}(\xi,\eta)=& (1-\xi_i)\textbf{X}(0,\eta_j)+\xi_i\textbf{X}(1,\eta_j) + (1-\eta_j)\textbf{X}(\xi_i,0)+\eta_j\textbf{X}(\xi_i,1) - \\
& \left\lbrack(1-\xi_i)(1-\eta_j)\textbf{X}(0,0)+(1-\xi_i)\eta_j\textbf{X}(0,1)+\xi_i(1-\eta_j)\textbf{X}(1,0)+\xi_i\eta_j\textbf{X}(1,1)\right\rbrack
\end{aligned}
\end{equation}

The \(\textbf{X}\) that appear on the right-hand side of the equation above are assumed to be known, and is how the physical domain boundary enters the meshing algorithm. For a straight-sided domain, with corner coordinates \((x_1,y_1), (x_2,y_2), (x_3,y_3), (x_4, y_4)\), where the first coordinate pair is in the lower left corner, the interpolation along the sides is given by:

\begin{equation}
\begin{aligned}
\textbf{X}(0,\eta_j)=\begin{bmatrix}(1-\eta_j)x_1+\eta x_4\\ (1-\eta_j)y_0+\eta y_4\end{bmatrix}\\
\textbf{X}(1,\eta_j)=\begin{bmatrix}(1-\eta_j)x_2+\eta x_3\\ (1-\eta_j)y_2+\eta y_3\end{bmatrix}\\
\textbf{X}(\xi_i,0)=\begin{bmatrix}(1-\xi_i)x_1+\xi_i x_2\\ (1-\xi_i)y_1+\xi_i y_2\end{bmatrix}\\
\textbf{X}(\xi_i,1)=\begin{bmatrix}(1-\xi_i)x_4+\xi_i x_3\\ (1-\xi_i)y_4+\xi_i y_3\end{bmatrix}\\
\end{aligned}
\end{equation}

where a 2-D domain is used for simplicity - the results would equally extend to 3-D. Then, inserting these into the Boolean sum above gives:

\begin{equation}
\begin{aligned}
x(\xi,\eta)=& (1-\xi_i)\left((1-\eta_j)x_1+\eta_j x_4\right)+\xi_i\left((1-\eta_j)x_2+\eta x_3\right) + \\
&(1-\eta_j)\left((1-\xi_i)x_1+\xi_i x_2\right)+\eta_j\left((1-\xi_i)x_4+\xi_i x_3\right) - \\
& \left\lbrack(1-\xi_i)(1-\eta_j)x_1+(1-\xi_i)\eta_jx_4+\xi_i(1-\eta_j)x_2+\xi_i\eta_jx_3\right\rbrack\\
=& \cancel{(1-\xi_i)(1-\eta_j)x_1}+\cancel{(1-\xi_i)\eta_j x_4}+\cancel{\xi_i(1-\eta_j)x_2}+\cancel{\eta_j x_3\xi_i} +\\
&(1-\eta_j)(1-\xi_i)x_1+\xi_i x_2(1-\eta_j)+\eta_j(1-\xi_i)x_4+\xi_i x_3\eta_j-\\
& \left\lbrack\cancel{(1-\xi_i)(1-\eta_j)x_1}+\cancel{(1-\xi_i)\eta_jx_4}+\cancel{\xi_i(1-\eta_j)x_2}+\cancel{\xi_i\eta_jx_3}\right\rbrack\\
=& (1-\eta_j)(1-\xi_i)x_1+\xi_i x_2(1-\eta_j)+\eta_j(1-\xi_i)x_4+x_3\eta_j\xi_i\\
\end{aligned}
\end{equation}

From the last line above, it is seen that, for the transformation from \(\xi\) to \(x\), the linear TFI is equivalent to bilinear interpolation between the four corner points. Similarly, bilinear interpolation between the \(y\)-coordinates of the four corner points is also equivalent to a bilinear interpolation (work follows the same steps shown above).

\begin{equation}
\begin{aligned}
y(\xi,\eta)= (1-\eta_j)(1-\xi_i)y_1+\xi_i y_2(1-\eta_j)+\eta_j(1-\xi_i)y_4+ y_3\eta_j\xi_i\\
\end{aligned}
\end{equation}

\section{}

TFI is used to generate a structured mesh of the given domain. The 1-D interpolations in the \(x\) and \(y\) directions now include four terms, two to account for control of the 1-D boundary values, and two to control for the 1-D boundary derivatives.

\begin{equation}
\begin{aligned}
\textbf{U}(\xi,\eta)=(2\xi_i^3-3\xi_i^2+1)\textbf{X}(0,\eta_j)+(3\xi_i^2-2\xi_i^3)\textbf{X}(1,\eta_j)+(\xi_i^3-2\xi_i^2+1)\frac{\partial\textbf{X}(0,\eta_j)}{\partial\xi}+(\xi_i^3-\xi_i^2)\frac{\partial\textbf{X}(1,\eta_j)}{\partial\xi}\\
\textbf{V}(\xi,\eta)=(2\eta_j^3-3\eta_j^2+1)\textbf{X}(\xi_i,0)+(3\eta_j^2-2\eta_j^3)\textbf{X}(\xi_i,1)+(\eta_j^3-2\eta_j^2+1)\frac{\partial\textbf{X}(\xi_i,0)}{\partial\eta}+(\eta_j^3-\eta_j^2)\frac{\partial\textbf{X}(\xi_i,1)}{\partial\eta}\\
\end{aligned}
\end{equation}

The 2-D interpolant is constructed from the 1-D interpolants by performing a Boolean sum:

\begin{equation}
\begin{aligned}
\textbf{X}(\xi,\eta)=& (2\xi_i^3-3\xi_i^2+1)\textbf{X}(0,\eta_j)+(3\xi_i^2-2\xi_i^3)\textbf{X}(1,\eta_j)+(\xi_i^3-2\xi_i^2+1)\frac{\partial\textbf{X}(0,\eta_j)}{\partial\xi}+(\xi_i^3-\xi_i^2)\frac{\partial\textbf{X}(1,\eta_j)}{\partial\xi}+\\
& (2\eta_j^3-3\eta_j^2+1)\textbf{X}(\xi_i,0)+(3\eta_j^2-2\eta_j^3)\textbf{X}(\xi_i,1)+(\eta_j^3-2\eta_j^2+1)\frac{\partial\textbf{X}(\xi_i,0)}{\partial\eta}+(\eta_j^3-\eta_j^2)\frac{\partial\textbf{X}(\xi_i,1)}{\partial\eta}-\\
& \left\lbrack(2\xi_i^3-3\xi_i^2+1)(2\eta_j^3-3\eta_j^2+1)\textbf{X}(0,0)+(3\xi_i^2-2\xi_i^3)(2\eta_j^3-3\eta_j^2+1)\textbf{X}(1,0)\right\rbrack-\\
& \left\lbrack(2\xi_i^3-3\xi_i^2+1)(3\eta_j^2-2\eta_j^3)\textbf{X}(0,1)+(3\xi_i^2-2\xi_i^3)(3\eta_j^2-2\eta_j^3)\textbf{X}(1,1)\right\rbrack\\
\end{aligned}
\end{equation}

\section{}

For a conformal map, an analytic function 

\begin{equation}
w=\frac{2e^z-3}{3e^z-2}
\end{equation}

\begin{equation}
\begin{aligned}
w=& \frac{2e^{x+iy}-3}{3e^{x+iy}-2}\\
=& \frac{2e^xe^{iy}-3}{3e^xe^{iy}-2}\\
=& \frac{2e^x(cos(y)+i\ sin(y))-3}{3e^x(cos(y)+i\ sin(y))-2}\\
=& \frac{2e^xcos(y)+2e^xi\ sin(y)-3}{3e^xcos(y)+3e^xi\ sin(y)-2}\\
\end{aligned}
\end{equation}

\section{}

Delaunay triangulation is used to generated an unstructured, triangular mesh of the given polygonal domain. For a given maximum element size, the boundary is discretized such that each element has a length as close as possible to \(h_{max}\), but not exceeding this value. Then, the domain is triangulated using Delaunay triangulation. Triangles outside the domain are deleted by placing a point at the midpoint of each side of every triangle, and then testing to see if that point is outside the domain using the {\tt inpolygon} command. This is a relatively simple method of determining whether a line is outside the polygon, and will only work for relatively simple geometries. For instance, if only a portion of a line extends outside the domain, then this procedure might not work, since the midpoint of the line might be inside the domain, but the entire line may not be inside the domain. This would require a constrained Delaunay formulation, which is beyond the scope of this assignment. 

Triangles with a side outside the domain are deleted, and the triangulation process repeated until all triangles have a size no larger than \(h_{max}^2/2\). Triangles with areas larger than this maximum value are considered to be poor triangles from a mesh quality standpoint, and their circumcenter is added. This algorithm is not implemented in a very robust manner, however, since that circumcenter must be in the domain for the refinement process to continue to completion, since if the circumcenter is outside the domain, then that point is deleted, and an infinite loop is entered. So, this is a second reason why my implementation only works for relatively simple geometries. Once all triangles have an area smaller than the maximum allowable area, the mesh if refined uniformly \(n_{ref}\) times. For each refinement, the center of each mesh edge is added, and the triangulation performed to get a roughly twice-as-fine mesh as the previous uniform refinement level. For the polygon given, Fig. \ref{fig:original} shows the Delaunay triangulation obtained for (a) zero, (b) one, and (c) two uniform refinements for \(h_{max}=0.2\).

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine0.png}
                \caption{\(n_{ref}=0\)}
        \end{subfigure}%
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine1.png}
                \caption{\(n_{ref}=1\)}
        \end{subfigure}%
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine2.png}
                \caption{\(n_{ref}=2\)}
        \end{subfigure}%
        \caption{Uniform refinement for the starting polygon.}
        \label{fig:original}
\end{figure}

Two more examples of different polygons are shown in Figs. \ref{fig:stop} and \ref{fig:2}.

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine-A0.png}
                \caption{\(n_{ref}=0\)}
        \end{subfigure}%
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine-A1.png}
                \caption{\(n_{ref}=1\)}
        \end{subfigure}%
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine-A2.png}
                \caption{\(n_{ref}=2\)}
        \end{subfigure}%
        \caption{Uniform refinement for different polygon, for \(h_{max}=4\).}
        \label{fig:stop}
\end{figure}

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine-B0.png}
                \caption{\(n_{ref}=0\)}
        \end{subfigure}%
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine-B1.png}
                \caption{\(n_{ref}=1\)}
        \end{subfigure}%
        \begin{subfigure}[b]{0.35\textwidth}
                \centering
                \includegraphics[width=\textwidth]{refine-B2.png}
                \caption{\(n_{ref}=2\)}
        \end{subfigure}%
        \caption{Uniform refinement for different polygon, for \(h_{max}=4\).}
        \label{fig:2}
\end{figure}

\end{document}

\end{document}